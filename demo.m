function NetPars = getDependentPars(NetPars)
    % Calculate dependent parameters in NetPars.
    
    % Wen-Hao Zhang, June-7, 2017
    % wenhaoz1@andrew.cmu.edu
    % @Carnegie Mellon University
    
    % Recalculate REFERENCE value for connection strength
    
    % Jc: the minimal recurrent connection strength for holding persistent
    %     activities after switching off feedforward input
    % Uc: the self-sustained bump height of synaptic input (without feedforward
    %     inputs) when recurrent connection strength is Jc
    % Oc: the self-sustained bump height of firing rate
    
    switch NetPars.connFunc
        case 'Gaussian'
            NetPars.rho = NetPars.N /(2*NetPars.Width); % The density of neurons
            NetPars.Jc  = sqrt(8*sqrt(2*pi)*NetPars.k*NetPars.TunWidth/NetPars.rho);
            NetPars.Uc  = NetPars.Jc/(2*sqrt(pi)*NetPars.k*NetPars.TunWidth);
            NetPars.Oc  = NetPars.Uc^2 ...
                /(1 + sqrt(2*pi)*NetPars.k*NetPars.rho*NetPars.TunWidth*NetPars.Uc^2);
        case 'vonMises'
            NetPars.rho = NetPars.N /(2*pi); % The density of neurons per degree
            NetPars.Jc  = 8*pi* NetPars.k/ NetPars.rho;
            NetPars.Jc  = NetPars.Jc * besseli(0, NetPars.TunKappa/2)^2 / besseli(0, NetPars.TunKappa);
            NetPars.Jc  = sqrt(NetPars.Jc); % 0.93 is an empirical factor to cancel the approximation in theory!
            NetPars.Uc  = NetPars.Jc*exp(NetPars.TunKappa/2)...
                / (2*pi*NetPars.k * besseli(0, NetPars.TunKappa/2));
            NetPars.Oc  = NetPars.Uc * exp(NetPars.TunKappa/2) * besseli(0, NetPars.TunKappa/2) ...
                /(NetPars.rho * NetPars.Jc * besseli(0, NetPars.TunKappa));
    end
    
    NetPars.Jrc = NetPars.JrcRatio * NetPars.Jc;
    NetPars.Jrp = NetPars.JrpRatio * NetPars.Jrc;
    NetPars.Ampl = NetPars.AmplRatio * NetPars.Uc;
end

function [parGrid, dimParGrid] = paramGrid(NetPars)
    % Generate parameter grid to scan the parameter space. 
    % The grid is generated by using the fields in NetPars who has
    % more than one COLUMN. 
    
    % Author: Wen-Hao Zhang, June-15, 2017
    % wenhaoz1@andrew.cmu.edu
    % @Carnegie Mellon University
    
    NetParsCell = struct2cell(NetPars);
    parNames = fieldnames(NetPars);
    
    % logical value indicating which variable has multiple values
    IdxPars_MultiVal = cellfun(@(x) (size(x, 2)>1) & (~ischar(x)), NetParsCell); 
    
    % The value of parameters which have multiple values
    parGridVal = NetParsCell(IdxPars_MultiVal);
    
    % size of parGrid this function will generate
    szParGrid = cellfun(@(x) size(x,2), NetParsCell(IdxPars_MultiVal))';
    
    %% 
    dimParGrid = [NetParsCell(IdxPars_MultiVal), ...
        parNames(IdxPars_MultiVal), ...
        mat2cell(cellfun(@(x) size(x,1), NetParsCell(IdxPars_MultiVal)), ones(1, sum(IdxPars_MultiVal)), 1)];
    dimParGrid = cell2struct(dimParGrid, {'valuePar', 'namePar', 'sizePar'}, 2)';
    
    %%
    parGrid = repmat(NetParsCell, [1, szParGrid]); % high-dim struct array
    parGrid = reshape(parGrid, size(parGrid,1), []); % 2D struct array, 
    % 1st dim is different parameters of a NetPars
    
    IdxPars_MultiVal = find(IdxPars_MultiVal);
    for iter = 1: length(szParGrid)
        % The value of parameter with multiple values
        xGridVal = mat2cell(parGridVal{iter}, size(parGridVal{iter},1), ones(1, szParGrid(iter))); % convert a mXn array into 1Xn cell with each a mX1 array
        xGridVal = shiftdim(xGridVal(:), 1-iter); % shift the dim to the order of this multiple parameter
        szRepmat = szParGrid;
        szRepmat(iter) = 1;
        xGridVal = repmat(xGridVal, szRepmat); % A 
        
        parGrid(IdxPars_MultiVal(iter), :) = xGridVal(:)';
    end
    
    if isempty(szParGrid)
        szParGrid = 1;
    end
    parGrid = reshape(parGrid, [size(parGrid, 1), szParGrid]); % reshape it into a high-dim struct array
    parGrid = cell2struct(parGrid, parNames);
end

function InputSet = makeNetInput(InputSet, NetPars, outArgs)
    % Make the inputs applied into decentralized network.
    
    % INPUT variables
    % InputSet: a void variable (struct) for initialization.
    % NetPars:  a struct stores all parameters of network
    % outArgs:  indicate which variables to be calculated and outputed.
    %           default is calculating Iext, ExtNois, InitNois and initialize
    %           RandomStream
    
    % OUTPUT variable
    % The InputSet is a struct contains following fields:
    % Iext:      [N, numNets, Time]
    % ExtNois:   external noise, which is the same size as Iext, 
    %            which has been divided by sqrt(dt)
    % IntNois:   internal noise, which is the same size as Iext, 
    %            which has been divided by sqrt(dt)
    % rsExtNois: RandomStream for external noise
    % rsIntNois: RandomStream for internal noise
    
    % Wen-hao Zhang, Dec-30-2016
    % wenhaoz1@andrew.cmu.edu
    % @Carnegie Mellon University
    
    if nargin == 2
        outArgs = struct('Iext', [], 'ExtNois', [], 'IntNois', [], ...
            'initRandStream', []);
    end
    
    % The size of external input
    szIext = [NetPars.N, NetPars.numNets, NetPars.tLen/NetPars.dt];
    
    %% Set RandStream for external and internal noise
    % if isfield(outArgs, 'initRandStream')
    %     if isfield(NetPars, 'seedNois')
    %         seedNois = NetPars.seedNois;
    %     else
    %         seedNois = sum(clock*100);
    %     end
    %     [rsExtNois, rsIntNois] = RandStream.create('mrg32k3a',...
    %         'NumStreams',2, 'seed', seedNois);
    %     
    %     % Fold variables into output struct
    %     InputSet.rsExtNois = rsExtNois;
    %     InputSet.rsIntNois = rsIntNois;
    % end
    
    %% Inputs without noise
    if isfield(outArgs, 'Iext')
        N       = NetPars.N;
        Width   = NetPars.Width;
        Ampl    = NetPars.Ampl;
        POSI    = NetPars.Posi;
          
        POSI = shiftdim(POSI, -1); % 1xnumNets)xT
        POSI = repmat(POSI, [N, 1, 1]); % NxnumNetsxT
        POSI = bsxfun(@minus, POSI, NetPars.PrefStim);
        
        switch NetPars.connFunc
            case 'Gaussian'
                % Add periodic condition
                POSI = angle(exp(1i*POSI * pi/Width)) * Width/pi;
                Iext = exp(-(POSI).^2/ (4*NetPars.TunWidth^2)); % [N, numNets, Time]
                Iext = bsxfun(@times, Ampl', Iext);
            case 'vonMises'
                POSI = angle(exp(1i*POSI * pi/Width)); % radian
                Iext = exp(NetPars.TunKappa/2 *(cos(POSI)-1) ); % [N, numNets, Time]
                Iext = bsxfun(@times, Ampl', Iext);
        end
        
        % Apply cueing condition
        switch NetPars.cueCond
            case 1 % Cue 1
                Iext(:, 2:2:end, :) = 0;
                % Iext(:, 2:2:end, :) = zeros(size(Iext)./[1,2,1]);
            case 2 % Cue 2
                Iext(:, 1:2:end, :) = 0;
        end
        
        % Fold variables into output struct
        InputSet.Iext = Iext;
        InputSet.szIext = szIext; % The desired size of Iext (used in static Iext)
    end
    
    %% External noise
    % if isfield(outArgs, 'ExtNois')
    %     ExtNois = randn(szIext) / sqrt(NetPars.dt);
    %     
    %     switch NetPars.typeExtNois
    %         case 'Gaussian'
    %             ExtNois = bsxfun(@times, shiftdim(NetPars.stdExtNois, -1), ExtNois);
    %         case 'Poisson'
    %             ExtNois = bsxfun(@times, sqrt(NetPars.fanoFactor*InputSet.Iext), ExtNois);
    %             % ExtNois = sqrt(NetPars.fanoFactor*InputSet.Iext) .* ExtNois;
    %     end
    %     
    %     % Apply cue condition
    %     switch NetPars.cueCond
    %         case 1 % Cue 1
    %             ExtNois(:, 2:2:end, :) = 0;
    %         case 2 % Cue 2
    %             ExtNois(:, 1:2:end, :) = 0;
    %     end
    % 
    %     % Fold variables into output struct
    %     InputSet.ExtNois = ExtNois;
    % end
    
    %% Internal noise
    % if isfield(outArgs, 'IntNois')
    %     IntNois = randn(InputSet.rsIntNois, szIext) / sqrt(NetPars.dt);
    %     IntNois = bsxfun(@times, shiftdim(NetPars.stdIntNois, -1), IntNois);
    %     
    %     % Fold variables into output struct
    %     InputSet.IntNois = IntNois;
    % end
    
end

function NetStat = statNetResponse(BumpPos, OHeight, UHeight, O, NetPars, NetStat)
    % Get the statistics of network responses
    
    % The input NetStat is a empty struct, the name of fields is used to
    % indicate which variables to output.
    
    % Author: Wen-Hao Zhang, June-7-2017
    % wenhaoz1@andrew.cmu.edu
    % @Carnegie Mellon University
    
    if isfield(NetStat, 'sumSqU')
        sumSqU = U;
        sumSqU(sumSqU<0) = 0;
        sumSqU = squeeze(sum(sumSqU.^pwr,1));
        NetStat.sumSqU = sumSqU;
    end
    
    if isfield(NetStat, 'OAvgXTime')
        NetStat.OAvgXTime = mean(O,3);
    end
    
    if isfield(NetStat, 'OStdXTime')
        NetStat.OStdXTime = std(O,[],3);
    end
    
    if isfield(NetStat, 'BumpPos')
        NetStat.BumpPos = BumpPos;
    end
    
    if isfield(NetStat, 'OHeight')
        NetStat.OHeight = OHeight;
    end
    
    if isfield(NetStat, 'OHeightAvg')
        OHeight = OHeight(:,NetPars.tStat/NetPars.dt+1:end, :);
        NetStat.OHeightAvg = mean(reshape(OHeight, size(OHeight, 1), []), 2);
        NetStat.OHeightAvg = squeeze(NetStat.OHeightAvg);
    end
    
    if isfield(NetStat, 'UHeightAvg')
        UHeight = UHeight(:,NetPars.tStat/NetPars.dt+1:end, :);
        NetStat.UHeightAvg = mean(reshape(UHeight, size(OHeight, 1), []), 2);
        NetStat.UHeightAvg = squeeze(NetStat.UHeightAvg);
    end
    
    if isfield(NetStat, 'meanBumpPos')
        BumpPos = BumpPos(:,NetPars.tStat/NetPars.dt+1:end, :);
        BumpPos = reshape(BumpPos, size(BumpPos,1), []);
        [~, meanBumpPos, varBumpPos, concBumpPos, mrlBumpPos] = statBumpPos(BumpPos, NetPars, 'BumpPos');
        
        NetStat.meanBumpPos = meanBumpPos;
    end
    
    if isfield(NetStat, 'varBumpPos')
        NetStat.varBumpPos  = varBumpPos;
    end
    
    if isfield(NetStat, 'concBumpPos')
        NetStat.concBumpPos = concBumpPos;
    end
    
    if isfield(NetStat, 'mrlBumpPos')
        NetStat.mrlBumpPos  = mrlBumpPos;
    end
end

function [InputSet, NetStat] = simCoupledAttractors1(InputSet, NetPars, outArgs)
    % A decentralized system for information integration
    % The whole system is composed of several networks, with each is modeled as
    % a continuous attractor neural network (CANN)
    
    % (ref. W.H. Zhang. et al., JNS 2016 and W.H. Zhang et al., NIPS 2016)
    % Features:
    % 1. Intra-network connections are translation-invariant bell shape function.
    % 2. Inter-network connections have the same profile but different strength
    %     with intra-network connections.
    
    % Author: Wen-Hao Zhang, Mar-13-2017
    % wenhaoz1@andrew.cmu.edu
    % @Carnegie Mellon University
    
    % Unfold parameters from struct NetPars and InputSet
    PrefStim    = NetPars.PrefStim;
    Width       = NetPars.Width;
    dt          = NetPars.dt;
    tau         = NetPars.tau;
    
    if nargin == 2
        outArgs = struct('InputSet', [], 'NetStat', []);
    end
    
    %% Connection kernel with unit connection strength
    switch NetPars.connFunc
        case 'Gaussian'
            TunWidth  = NetPars.TunWidth;
            KerFt = angle(exp(1i*(PrefStim - PrefStim(1)) *pi/Width))* Width/pi;
            KerFt = exp(-KerFt.^2/(2*TunWidth^2))/(sqrt(2*pi)*TunWidth);
        case 'vonMises'
            TunKappa  = NetPars.TunKappa;
            KerFt = angle(exp(1i*(PrefStim - PrefStim(1)) *pi/Width)); % unit: rad
            KerFt = exp(TunKappa * cos(KerFt) )/(2*pi*besseli(0, TunKappa));
    end
    KerFt = fft(KerFt);
    
    % Weight matrix
    if ~isfield(NetPars, 'JMat')
        % The matrix will be right multiply with neural firing rate R (N-by-2 array);
        JMat = (1 - NetPars.JrpRatio) * diag(ones(1, NetPars.numNets)) ...
            + NetPars.JrpRatio * ones(NetPars.numNets);
        JMat = JMat * NetPars.Jrc;
    else
        JMat = NetPars.JMat;
    end
    
    %% Initiation
    % [N, numNets, Time, nTrials]
    sizeU = [NetPars.N, NetPars.numNets, ...
        NetPars.tLen/NetPars.dt, NetPars.nTrials];
    if isfield(outArgs, 'InputSet')
        UArray = zeros(sizeU);
        OArray = zeros(sizeU);
    end
    if isfield(outArgs, 'NetStat')
        BumpPos = zeros(sizeU(2:end));
        OHeight = zeros(size(BumpPos));
        UHeight = zeros(size(BumpPos));
    end
    
    % Reset the random seed
    rng(NetPars.seedNois);
    
    %% Iteration
    for iterTrial = 1: NetPars.nTrials
        U = zeros(sizeU(1:3));
        O = zeros(sizeU(1:3));
        
        % ------------------------------------------
        % Generate new noise sequence of every trial
        %     InputSet = makeNetInput(InputSet, NetPars, ...
        %         struct('ExtNois', [], 'IntNois', []));
        
        % Add the mean value of background inputs
        Iext = InputSet.Iext + NetPars.AmplBkg;
        
        % -----------------------------------------------------------
        % Iteration over time
        for t = 1: InputSet.szIext(3) - 1
            OFt = fft(O(:,:, t));
            
            % Inputs received by congruent neurons
            ISyn = bsxfun(@times, KerFt,  OFt); % Nx2
            ISyn = ifft(ISyn) * JMat;
            
            % Update
            dU = (-U(:,:,t) + ISyn + Iext) * dt/tau;
            %         dU = dU + sqrt(NetPars.fanoFactor * O(:,:,t)*dt/tau).*randn(NetPars.N, NetPars.numNets);
            dU = dU + sqrt(NetPars.fanoFactor * U(:,:,t).*(U(:,:,t)>0)*dt/tau)...
                .*randn(NetPars.N, NetPars.numNets);
            
            U(:,:,t+1) = U(:,:,t) + dU;
            
            % Synaptic input --> Firing rate
            Urec = U(:,:,t+1);
            Urec(Urec<0) = 0;
            Urec = Urec.^2;
            divU = NetPars.k * sum(Urec, 1);
            
            O(:,:,t+1) = bsxfun(@rdivide, Urec, 1+divU);
            % O(:,:,t+1) = O(:,:,t+1) + sqrt(NetPars.fanoFactor * O(:,:,t+1)) ...
            %    .* randn(NetPars.N, NetPars.numNets);
            % O(:,:,t+1) = O(:,:,t+1) .* (O(:,:,t+1)>0) ;
        end
        
        if isfield(outArgs, 'InputSet')
            UArray(:,:,:,iterTrial) = U;
            OArray(:,:,:,iterTrial) = O;
        end
        
        % Make statistics of network's activities
        % Calculate the bump position and height
        if exist('BumpPos', 'var')
            BumpPos(:,:,iterTrial) = statBumpPos(O, NetPars);
        end
        if exist('OHeight', 'var')
            OHeight(:,:,iterTrial) = sum(O,1)/ (sqrt(2*pi)*NetPars.TunWidth * NetPars.rho);
            UHeight(:,:,iterTrial) = sum(U,1)/ (2*sqrt(pi)*NetPars.TunWidth * NetPars.rho);
        end
    end
    
    %% Estimate the statistics of network activities
    if isfield(outArgs, 'NetStat')
        NetStat = statNetResponse(BumpPos, OHeight, UHeight, O, NetPars, outArgs.NetStat);
    end
    
    %% Fold variables into output struct
    if isfield(outArgs, 'InputSet')
        InputSet.U = UArray;
        InputSet.O = OArray;
    end
end

function kappa = mrl2Kappa(mrl)
    % kappa = mrl2Kappa(mrl)
    %  Convert the mean resultant length of a circular distribribution to the
    %  concentration parameter kappa of the von-Mises distribution, by using an
    %  approximated ML method
    
    %  Input:
    %    mrl: mean resultant length
    
    %  Output:
    %    kappa: estimated concentration parameter
    
    % Wen-Hao Zhang, Apr-7,2016
    
    kappa = zeros(size(mrl));
    
    Idx = (mrl<0.53);
    kappa(Idx) = 2*mrl(Idx) + mrl(Idx).^3 + 5*mrl(Idx).^5/6;
    
    Idx = (mrl>=0.53) & (mrl<0.85);
    kappa(Idx) = -.4 + 1.39*mrl(Idx) + 0.43./(1-mrl(Idx));
    
    Idx = (mrl>=0.85);
    kappa(Idx) = 1./(mrl(Idx).^3 - 4*mrl(Idx).^2 + 3*mrl(Idx));
    
    % if mrl < 0.53
    %   kappa = 2*mrl + mrl.^3 + 5*mrl.^5/6;
    % elseif mrl>=0.53 && mrl<0.85
    %   kappa = -.4 + 1.39*mrl + 0.43/(1-mrl);
    % else
    %   kappa = 1/(mrl.^3 - 4*mrl.^2 + 3*mrl);
    % end
    
    % if N<15 && N>1
    %   if kappa < 2
    %     kappa = max(kappa-2*(N*kappa)^-1,0);    
    %   else
    %     kappa = (N-1)^3*kappa/(N^3+N);
    %   end
    % end
end

function [BumpPos, meanBumpPos, varBumpPos, concBumpPos, mrlBumpPos] = statBumpPos(Input, NetPars, inputName)
    % Calculate the bump position by projecting network
    % bump on an unit circle
    
    % Wen-hao Zhang, Dec-31-2016
    
    if nargin < 3
        inputName = 'O'; % Firing rate
    end
    
    switch inputName
        case 'O'
            cirPos = exp(1i * NetPars.PrefStim/ NetPars.Width * pi);
            
            % BumpPos = squeeze(mean(bsxfun(@times, cirPos, O), 1)); % average over all neurons
            BumpPos = mean(bsxfun(@times, cirPos, Input), 1); % average over all neurons
            BumpPos = shiftdim(BumpPos, 1);
            BumpPos = BumpPos ./ abs(BumpPos); % normalize
            %         BumpPos(isnan(BumpPos)) = 0;
            IdxNaN = isnan(BumpPos);
    %         BumpPos(IdxNaN(:)) = 360*rand(1, sum(IdxNaN(:)))-180;
            BumpPos(IdxNaN(:)) = exp(1i * (2*pi*rand(1, sum(IdxNaN(:))) - pi));
        case 'BumpPos'
            BumpPos = exp(1i * Input/ NetPars.Width * pi);
    end
    
    if nargout == 1
       BumpPos = angle(BumpPos)* NetPars.Width/pi; % angular value 
       return;
    end
    
    if isempty(BumpPos)
        % This case may happen when input variable is BumpPos
        szBumpPos = size(BumpPos);
        szBumpPos(2) = 1;
        meanBumpPos = nan(szBumpPos);
        varBumpPos = nan(szBumpPos);
        concBumpPos = nan(szBumpPos);
        mrlBumpPos = nan(szBumpPos);
    else
        % Concentration of distribution of BumpPos
        % For directional statistics, the concentration is the absolute value of summed points
        meanBumpPos = mean(BumpPos, 2); % complex number
        
        mrlBumpPos = abs(meanBumpPos); % mean resultant length, average over time
        concBumpPos = mrl2Kappa(mrlBumpPos); % concentration parameter
        
        % Angular
        meanBumpPos = angle(meanBumpPos)* NetPars.Width/pi; % angular value
        BumpPos = angle(BumpPos)* NetPars.Width/pi; % angular value
        
        % Variance
        devBumpPos = bsxfun(@minus, BumpPos, meanBumpPos);
        devBumpPos(devBumpPos>NetPars.Width) = devBumpPos(devBumpPos>NetPars.Width) - 2*NetPars.Width;
        devBumpPos(devBumpPos<NetPars.Width) = devBumpPos(devBumpPos<NetPars.Width) + 2*NetPars.Width;
        % varBumpPos = devBumpPos * devBumpPos'/ (size(devBumpPos,2)-1);
        % varBumpPos = sum(devBumpPos.^2, 2) / (size(devBumpPos,2)-1);
        varBumpPos = cov(devBumpPos');
    end
end

function [Lambda_s, KLD] = findPriorPrecision(muS, covS, muLH, invCovLH)
    % Find the prior precision stored in the neural network given
    % 1) the sample distribution generated by network dynamics, and the
    % 2) likelihood parameters
    
    % Prior precision: Lambda_s
    
    % Input:
    % 1) muLH: the mean of likelihood, calculated from theory,
    % 2) invCovLH: the precision matrix of likelihood.
    
    % Output:
    % 1) Lambda_s: the precision of the Laplacian precision matrix in
    %              prior, which denotes the correlation between two stimuli;
    % 2) KLD: the KL divergence from the searched posterior and the actual
    %         sample distribution.
    
    % Wen-Hao Zhang, Apr. 15, 2020
    % University of Pittsburgh
    
    
    % The initial value in optimization
    invCovPost0 = inv(covS);
    maxLambda_s = 2*invCovPost0(1);
    Lambda_s0 = - invCovPost0(1,2);
    
    % Find the Lambda_s making the posterior closet to the sample distribution
    options = optimset('TolX', 1e-4, 'display', 'off');
    Lambda_s = fmincon(@(lambda) computeKLD(lambda), Lambda_s0, [], [], [], [], ...
        0, maxLambda_s, [], options);
    KLD = computeKLD(Lambda_s);
    
    function KLDiv = getKLDiv(mu0, Cov0, mu, Cov)
        % Calculate the KL divergence from normal distributions 
        %   N(mu0, Cov0) to N(mu, Cov)
        % Wen-Hao Zhang, June 27, 2019
        % University of Pittsburgh
        
        
        KLDiv = log(det(Cov)) - log(det(Cov0)) ...
            + trace(Cov0 / Cov) ...
            + (mu - mu0)' / Cov * (mu - mu0);
        KLDiv = KLDiv /2 - length(Cov0)/2;
    end

    function KLDiv = computeKLD(Lambda_s)
        % The precision matrix of the posterior
        invCovPost = 2*diag(ones(1, length(invCovLH))) - ones(size(invCovLH));
        invCovPost = Lambda_s * invCovPost;
        invCovPost = invCovPost + invCovLH;
        
        % The mean of the posterior
        muPost = invCovPost \ invCovLH * muLH;
        
        KLDiv = getKLDiv(muPost, inv(invCovPost), muS, covS);
    end
end

% Load parameters
% Parameters for coupled two CANNs
%% Load default network parameters
% Default parameters of network
NetPars.N        = 180;  % The number of neurons
NetPars.numNets  = 1;  % number of networks
NetPars.Width    = 180; % the range of parameter space from (-Width, Width), unit: deg

% Preferred stimulus of neurons (location on feature space)
PrefStim         = linspace(-NetPars.Width,NetPars.Width, NetPars.N+1)'; 
PrefStim(1)      = [];
NetPars.PrefStim = PrefStim;
clear PrefStim

%% Temporal parameters
NetPars.tau  = 1; % Time constant of neuron activity
NetPars.tLen = 600 * NetPars.tau; % whole length of simulation
NetPars.dt   = NetPars.tau/100; % the iterative step

%% Connection
% NetPars.connFunc = 'vonMises'; % or Gaussian
NetPars.connFunc = 'Gaussian'; % or vonMises
switch NetPars.connFunc
    case 'Gaussian'
        NetPars.k         = 5e-4; % global inhibition strength
        NetPars.TunWidth  = 40; % Tuning width, the std. of tuning function. Unit: deg.
    case 'vonMises'
        NetPars.k           = 3e-4; % global inhibition strength
        NetPars.TunKappa    = 3; % Tuning width, concentration of von-Mises function, about 40 deg.
end
NetPars.JrcRatio = 0.5; % Recurrent connection strength within the same network, relative to Jc (the minimal recurrent 
%                         connection strength for the network to hold a persistent activity without feedforward inputs).
NetPars.JrpRatio = 0.4; % Reciprocal connection strength between networks; same parameter for J12 and J21, relative to Jrc

%% Network input 
% -----------------------------
% Input intensity and location
% -----------------------------
% Peak intensity of feedforward inputs, [numNets, 1]
NetPars.AmplRatio = 0.6; % Relative to Uc, which is the persistent bump height without stimulus when Jrc = Jc 
NetPars.AmplRatio = repmat(NetPars.AmplRatio, [NetPars.numNets, 1]);

% Intensity of background input
NetPars.AmplBkg = 0; 

% Input location, [numNets, 1]
NetPars.Posi = 0;
clear Posi

% ------------------
% Noise structure
% ------------------
NetPars.bAddNoise = 1; % 1: add noise; 0: noise free;
% NetPars.PosiNoise = 0; % bool variable, 1: noise on the position of external input; 0: full noise

% Internal noise inside network
% The noise strength of all networks are the same for simplicity
NetPars.fanoFactor = 1; % fano factor of internal noise

% External noise associated with feedforward connections
% NetPars.typeExtNois = 'Poisson'; % or 'Gaussian'

% ------------------
% Cueing conditions
% ------------------
NetPars.cueCond = 0; % Cueing condition. 
%                         0: both cue; 
%                         1: only cue 1; 
%                         2: only cue 2.

% Random seed
NetPars.seedNois = 0;
% NetPars.seedIntNois = 0;
% NetPars.seedExtNois = sum(clock)*100;

NetPars.flagSeed = 1;
switch NetPars.flagSeed
    case 1
        NetPars.flagSeed = 'sameSeed';
        % use the same random seed for all parameters 
    case 2
        NetPars.flagSeed = 'SameSeedCueCond';
        % different random seed under different parameter settings, but for
        % each parameter set, the seeds under three cue conditions are
        % exactly the same
    case 3
        NetPars.flagSeed = 'diffSeed';
end

NetPars = orderfields(NetPars);

%% Specialized parameters of CANN
NetPars.numNets = 2;
NetPars = getDependentPars(NetPars);

%% Caution: don't move below lines before parseNetPars
% NetPars.Jrc      = 0.5*NetPars.Jc;
NetPars.JrcRatio = 1./sqrt(2)/NetPars.Jc;
NetPars.JrpRatio = 0.7; % same parameter for J12 and J21, relative to Jrc

% -----------------
% Input parameters
% -----------------
NetPars.AmplRatio = 0.7*NetPars.Uc;
NetPars.AmplRatio = repmat(NetPars.AmplRatio, [NetPars.numNets, 1]);

NetPars.Posi = ...
    [NetPars.PrefStim(end/2-1), ...
    NetPars.PrefStim(end/2+1)]'; % the last element is used for different position

NetPars.stdIntNois = sqrt(NetPars.AmplBkg * NetPars.fanoFactor); % internal noise
NetPars.stdIntNois = repmat(NetPars.stdIntNois, [NetPars.numNets, 1]);

NetPars.bAddNoise = 1;
NetPars.AmplBkg = 0;


% Parameters of multiple trials
NetPars.tTrial  = 500 * NetPars.tau;
NetPars.nTrials = 1; % number of trials
NetPars.tLen    = NetPars.nTrials * NetPars.tTrial;
NetPars.tStat   = 50 * NetPars.tau; % The starting time to make statistics
%%
% Parse network parameters
%% Check the size of Input variables
if (size(NetPars.AmplRatio, 1) ~= NetPars.numNets)
    error('The dim. of NetPars.Ampl does not match with num. of nets.')
end

if (size(NetPars.Posi, 1) ~= NetPars.numNets)
    error('The dim. of NetPars.Posi does not match with num. of nets.')
end

% if strcmp(NetPars.typeExtNois, 'Gaussian')
%     if (size(NetPars.stdExtNois, 1) ~= NetPars.numNets)
%         error('The dim. of stdExtNois does not match with num. of nets.')
%     end
% end

if length(NetPars.PrefStim) ~= NetPars.N   
    PrefStim         = linspace(-NetPars.Width,NetPars.Width, NetPars.N+1)';
    PrefStim(1)      = [];
    NetPars.PrefStim = PrefStim;
    clear PrefStim
end

if (size(NetPars.stdIntNois, 1) ~= NetPars.numNets)
    error('The dim. of stdIntNois does not match with num. of nets.')
end


NetPars.AmplRatio = 1*ones(NetPars.numNets,1);
NetPars.JrcRatio = 0.5;
NetPars.JrpRatio = 0.8;
NetPars.tLen = 1e3;

NetPars.fanoFactor = 0.5;
NetPars.Posi = 2*[-1;1];

% Generate grid of parameters
[parGrid, dimPar] = paramGrid(NetPars);
parGrid = arrayfun(@(x) getDependentPars(x), parGrid);

%% Net Simulation
NetStat = struct('BumpPos', [], ...
    'meanBumpPos', [], ...
    'varBumpPos', [], ...
    'OHeightAvg', [], ...
    'OAvgXTime', [], ...
    'OStdXTime', [], ...
    'UHeightAvg', []);
NetStat = repmat(NetStat, size(parGrid));

tStart = clock;
for iterPar = 1: numel(parGrid)
    fprintf('Progress: %d/%d\n', iterPar, numel(parGrid));
    netpars = parGrid(iterPar);
    
    % Network input
    InputSet = makeNetInput([], netpars);
    
    % Run simulation
    outArgs = struct('InputSet', [], 'NetStat', NetStat(iterPar));
    [InputSet, NetStat(iterPar)] = simCoupledAttractors1(InputSet, netpars, outArgs);
end

tEnd = clock;

%% Parameters of sample distributions
PreMat_Sample = {NetStat.varBumpPos};
PreMat_Sample = cellfun(@inv, PreMat_Sample, 'uniformout', 0);
PreMat_Sample = reshape(cell2mat(PreMat_Sample), NetPars.numNets, NetPars.numNets, []);

%% Theoretical prediction

wfwd = 8/3^(3/2) * NetPars.fanoFactor * 2.5;

% New version includes the spatial convolution of the feedforward input.
PreMat_LH = 2*sqrt(pi) * diag(parGrid(1).Ampl) / NetPars.TunWidth/ wfwd;

% ------------------------------------------------------
% The variance of noise is the firing rate bump
% varBumpPosTheory = [NetStat.OHeightAvg]./ [NetStat.UHeightAvg]*NetPars.TunWidth ...
%     ./ (2*sqrt(pi) .*[parGrid.Ampl]);

% The variance of noise is the synaptic input bump
varBumpPosTheory = 4*NetPars.fanoFactor*NetPars.TunWidth/sqrt(pi)/ 3^(3/2) ./ [parGrid.Ampl];

% ------------------------------------------------------
% Prediction of mean of samples
% Find the prior precision which best explains the sample distribution
meanSampleTheory = zeros(NetPars.numNets, numel(parGrid));
Lambda_s = zeros(1, numel(parGrid));
KLD = zeros(1, numel(parGrid));

for iter = 1: numel(NetStat)
    meanSampleTheory(:,iter) = NetStat(iter).varBumpPos * ...
        PreMat_LH * NetPars.Posi;
    [Lambda_s(iter), KLD(iter)] = findPriorPrecision(NetStat(iter).meanBumpPos, NetStat(iter).varBumpPos, ...
        NetPars.Posi, PreMat_LH);
end
meanSampleTheory = reshape(meanSampleTheory, [NetPars.numNets, size(parGrid)]);
OmegaTheory = PreMat_LH + Lambda_s * (2*diag(ones(1, NetPars.numNets)) - ones(size(NetPars.numNets)));

%% Plot

tPlot = 1e4+1e2;
tlenPlot = 5e2;

figure
% Plot the empirical distribution of samples
hAxe = plotJointMarginalHist(NetStat.BumpPos(1,NetPars.tStat/NetPars.dt+1:end), ...
    NetStat.BumpPos(2,NetPars.tStat/NetPars.dt+1:end));

% Get the range of coordinates
xLim = get(hAxe(1), 'xlim');
yLim = get(hAxe(1), 'ylim');
xGrid = linspace(xLim(1), xLim(end), 1e2+1);
yGrid = linspace(yLim(1), yLim(end), 1e2+1);

% Contour or the color image of the empirical distribution of samples
[X,Y] = ndgrid(xGrid, yGrid);
pdfSample = mvnpdf([X(:), Y(:)], NetStat.meanBumpPos', NetStat.varBumpPos);
pdfSample = reshape(pdfSample, size(X));
% imagesc(hAxe(1), xGrid, yGrid, pdfSample')
contour(X,Y, pdfSample)
caxis([-5e-2, max(pdfSample(:))])
axis xy

% Plot the distribution of posterior predicted by Bayes theorem
SigmaS = inv(OmegaTheory);
fPostBayes = @(x,y) ( ([x;y] - meanSampleTheory)' * OmegaTheory * ([x;y]-muS) - 9);
hEllipse = fimplicit(hAxe(1), fPostBayes, ...
    [SigmaS(1) + 5*SigmaS(1)*[-1, 1], meanSampleTheory(2) + 5*SigmaS(4)*[-1, 1]], ...
    'color', 'k', 'linestyle', '--', 'linew', 2);
plot(hAxe(2), xGrid, normpdf(xGrid, meanSampleTheory(1), sqrt(SigmaS(1))), '--k', 'linew',2)
plot(hAxe(3), normpdf(yGrid, meanSampleTheory(2), sqrt(SigmaS(2,2))), yGrid, '--k', 'linew',2)


% Plot an example of trajectory
cMap = cool(tlenPlot);
for iter = 1: (tlenPlot-1)
    plot(NetStat.BumpPos(1,tPlot+(iter:iter+1)), NetStat.BumpPos(2,tPlot+(iter:iter+1)), 'color', cMap(iter,:));
end

axes(hAxe(1))
xlabel('s_1')
ylabel('s_2')

